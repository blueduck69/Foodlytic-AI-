
import { GoogleGenAI, Type } from "@google/genai";
import { FoodAnalysis, HealthLabel, LanguageCode, SafetyLevel, SUPPORTED_LANGUAGES } from "../types";

export const analyzeFoodIngredients = async (
  input: string | { data: string; mimeType: string },
  isImage: boolean = false,
  languageCode: LanguageCode = 'en'
): Promise<FoodAnalysis> => {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  const langName = SUPPORTED_LANGUAGES.find(l => l.code === languageCode)?.name || 'English';

  const responseSchema = {
    type: Type.OBJECT,
    properties: {
      productName: { type: Type.STRING },
      ingredients: {
        type: Type.ARRAY,
        items: {
          type: Type.OBJECT,
          properties: {
            name: { type: Type.STRING },
            code: { type: Type.STRING },
            category: { type: Type.STRING }
          },
          required: ["name", "category"]
        }
      },
      additives: {
        type: Type.ARRAY,
        items: {
          type: Type.OBJECT,
          properties: {
            name: { type: Type.STRING },
            purpose: { type: Type.STRING },
            safetyLevel: { type: Type.STRING, enum: Object.values(SafetyLevel) },
            sideEffects: { type: Type.STRING },
            regulatoryStatus: { type: Type.STRING }
          },
          required: ["name", "purpose", "safetyLevel", "sideEffects", "regulatoryStatus"]
        }
      },
      healthInsights: {
        type: Type.OBJECT,
        properties: {
          childrenFriendly: { type: Type.STRING },
          pregnancySafe: { type: Type.STRING },
          allergies: { type: Type.STRING },
          dietary: { type: Type.STRING }
        },
        required: ["childrenFriendly", "pregnancySafe", "allergies", "dietary"]
      },
      score: { type: Type.NUMBER },
      label: { type: Type.STRING, enum: Object.values(HealthLabel) },
      alternatives: { type: Type.ARRAY, items: { type: Type.STRING } },
      verdict: { type: Type.STRING }
    },
    required: ["ingredients", "additives", "healthInsights", "score", "label", "alternatives", "verdict"]
  };

  const systemInstruction = `You are an elite Food Safety & Nutrition Specialist. 
Analyze the input food ingredients and produce a comprehensive health report. 
Language: ${langName}.

Rules:
1. Identify every chemical additive and preservative (E-numbers).
2. Rate safety as SAFE (green), CAUTION (yellow), or AVOID (red).
3. Score the product 1-10 (1 is ultra-processed/harmful, 10 is natural/healthy).
4. Provide specific impacts on children and long-term health.
5. Suggest healthier, minimally processed alternatives available in common grocery stores.
6. Return a valid JSON object matching the requested schema.`;

  try {
    const contents = isImage && typeof input !== 'string' 
      ? { parts: [{ inlineData: input }, { text: `Extract all ingredients from this label and provide a safety analysis in ${langName}. Return as JSON.` }] }
      : { parts: [{ text: `Analyze these ingredients and provide a detailed safety report in ${langName}: ${input}` }] };

    const response = await ai.models.generateContent({
      model: "gemini-3-flash-preview",
      contents,
      config: {
        systemInstruction,
        responseMimeType: "application/json",
        responseSchema,
        temperature: 0.1,
      },
    });

    const text = response.text;
    if (!text) {
      throw new Error("No response generated by the AI. The image might be too blurry.");
    }

    // Advanced JSON Extraction Logic
    let jsonStr = text.trim();
    
    // Remove Markdown code block syntax if present
    if (jsonStr.includes('```')) {
      const match = jsonStr.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
      if (match && match[1]) {
        jsonStr = match[1];
      }
    }

    try {
      return JSON.parse(jsonStr) as FoodAnalysis;
    } catch (parseError) {
      console.error("JSON Parse Error. Raw text:", text);
      throw new Error("Failed to parse analysis data. Please try again with a different photo.");
    }
  } catch (error: any) {
    console.error("Gemini Service Error:", error);
    
    // Enhanced error mapping
    if (error.message?.includes('API_KEY')) {
      throw new Error("Application configuration error: API Key invalid.");
    }
    
    if (error.status === 429) {
      throw new Error("Too many requests. Please wait a moment before analyzing again.");
    }

    throw error;
  }
};
